<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas - Camera & Star Fix</title>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        #input_video {
            display: none;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body class="bg-black">

    <video id="input_video" style="display:none;"></video>

    <!-- Shader -->
    <script type="x-shader/x-vertex" id="vertexshader">
        attribute float size;
        attribute vec3 customColor;
        attribute vec3 spherePos; 
        attribute float type;     
        varying vec3 vColor; varying float vType;
        uniform float uTime; uniform float uExplosion; uniform float uBeat;      
        void main() {
            vColor = customColor; vType = type;
            float t = uExplosion;
            float ease = 1.0 - pow(1.0 - t, 3.0);
            vec3 finalPos = mix(position, spherePos, ease);
            float beatScale = 1.0;
            if (t < 0.2) beatScale += uBeat * 0.15 * (1.0 - t*3.0); 
            if (type > 0.5) beatScale += uBeat * 0.2; 
            vec4 mvPosition = modelViewMatrix * vec4(finalPos * beatScale, 1.0);
            float s = size;
            if(type > 0.5) s *= (1.0 + uBeat * 0.5);
            gl_PointSize = s * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
        }
    </script>
    <script type="x-shader/x-fragment" id="fragmentshader">
        uniform float uTime; uniform float uBeat;
        varying vec3 vColor; varying float vType;
        void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            if(length(coord) > 0.5) discard;
            vec3 color = vColor; float alpha = 1.0;
            if(vType > 0.5) {
                float flash = 0.5 + 0.5 * sin(uTime * 5.0 + vType * 10.0);
                color += vec3(0.5) * flash * uBeat * 2.0;
            } else { alpha = 0.8; }
            gl_FragColor = vec4(color, alpha);
        }
    </script>

    <script>
        const state = {
            explosion: 0.0,
            targetExplosion: 0.0,
            treeHeight: 100, // 增加树高
            rotationSpeed: 0.002
        };

        let scene, camera, renderer, clock;
        let particleSystem, treeGroup, starMesh;
        let audioCtx, analyser, dataArray, audioEl;
        let snowTrails = [];
        let groundGlow;
        let ribbonCurves = [];
        let starGlow;
        let explosionRings = [];
        
        initAudio();
        initThree();
        startHandTracking();

        function initAudio() {
            audioEl = new Audio();
            audioEl.crossOrigin = "anonymous";
            audioEl.src = "https://thirdparty.gtimg.com/C1000007bNrR1HXkjD.m4a?fromtag=38";
            audioEl.loop = true;
            
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            
            const source = audioCtx.createMediaElementSource(audioEl);
            source.connect(analyser);
            analyser.connect(audioCtx.destination);
            
            audioEl.play().catch(e => console.log("需要交互", e));
        }

        function initThree() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.004);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 180);
            camera.lookAt(0, 50, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            treeGroup = new THREE.Group();
            scene.add(treeGroup);
            
            // 创建地面光晕
            const glowGeo = new THREE.CircleGeometry(80, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0x001a5f,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });
            groundGlow = new THREE.Mesh(glowGeo, glowMat);
            groundGlow.rotation.x = -Math.PI / 2;
            groundGlow.position.y = -12;
            scene.add(groundGlow);
            
            // 创建环绕彩带曲线
            createRibbonCurves();

            createParticles();
            createStar();
            createSnow();
            animate();
        }

        function createParticles() {
            if(particleSystem) { treeGroup.remove(particleSystem); particleSystem.geometry.dispose(); }
            const count = 35000; // 减少30%粒子
            const geo = new THREE.BufferGeometry();
            const positions = [], spherePos = [], colors = [], sizes = [], types = [];
            const h = state.treeHeight;
            const colorHelper = new THREE.Color();

            for(let i=0; i<count; i++) {
                const y = (i/count) * h;
                const rBase = (1 - y/h) * (h*0.5); // 增加树宽
                const angle = i * 0.2;
                const r = rBase * Math.sqrt(Math.random());
                positions.push(Math.cos(angle)*r, y - 10, Math.sin(angle)*r);

                const v = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                v.multiplyScalar(60 + Math.random()*80); // 增加爆炸范围
                spherePos.push(v.x, v.y + 30, v.z);

                const rnd = Math.random();
                // 增加彩灯比例，添加更多颜色
                if(rnd > 0.94) { types.push(2); sizes.push(5); colorHelper.setHex(0xffaa00); } // 金色
                else if(rnd > 0.88) { types.push(1); sizes.push(4); colorHelper.setHex(Math.random()>0.5?0xff0000:0x00aaff); } // 红蓝
                else if(rnd > 0.82) { types.push(1); sizes.push(4); colorHelper.setHex(0xff00ff); } // 紫色
                else if(rnd > 0.76) { types.push(1); sizes.push(4); colorHelper.setHex(0x00ff00); } // 绿色
                else if(rnd > 0.70) { types.push(1); sizes.push(4); colorHelper.setHex(0xffff00); } // 黄色
                else if(rnd > 0.64) { types.push(1); sizes.push(4); colorHelper.setHex(0xff6600); } // 橙色
                else if(rnd > 0.58) { types.push(1); sizes.push(4); colorHelper.setHex(0x00ffff); } // 青色
                else if(rnd > 0.52) { types.push(1); sizes.push(4); colorHelper.setHex(0xff0099); } // 粉色
                else { types.push(0); sizes.push(2.5); colorHelper.setHex(0x228b22); } // 绿叶
                
                colors.push(colorHelper.r, colorHelper.g, colorHelper.b);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('spherePos', new THREE.Float32BufferAttribute(spherePos, 3));
            geo.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            geo.setAttribute('type', new THREE.Float32BufferAttribute(types, 1));

            state.uniforms = { uTime: { value: 0 }, uExplosion: { value: 0 }, uBeat: { value: 0 } };
            const mat = new THREE.ShaderMaterial({
                uniforms: state.uniforms, vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                blending: THREE.AdditiveBlending, depthTest: false, transparent: true
            });

            particleSystem = new THREE.Points(geo, mat);
            treeGroup.add(particleSystem);
        }

        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            let beat = 0;
            if(analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for(let i=0; i<15; i++) sum+=dataArray[i];
                beat = (sum/15/255) * 1.0;
            }

            if(state.uniforms) {
                state.uniforms.uTime.value = t;
                state.uniforms.uBeat.value = beat;
                state.explosion += (state.targetExplosion - state.explosion) * 0.05;
                state.uniforms.uExplosion.value = state.explosion;
            }

            treeGroup.rotation.y += state.rotationSpeed + state.explosion * 0.01;

            if(starMesh) {
                starMesh.rotation.y -= 0.02;
                const s = 1 + beat * 0.3 + state.explosion * 0.5;
                starMesh.scale.set(s,s,s);
            }
            
            // 小星星闪烁动画
            if(window.smallStars) {
                const t = clock.getElapsedTime();
                window.smallStars.forEach((star, i) => {
                    star.rotation.y += 0.01;
                    star.material.opacity = 0.5 + 0.3 * Math.sin(t * 2 + i * 0.5);
                });
            }
            
            // 曲线旋转动画
            if(window.ribbonCurves) {
                window.ribbonCurves.forEach((tube, i) => {
                    tube.rotation.y += 0.003;
                });
            }
            
            // 树顶星星优雅光晕律动
            if(starGlow && starGlow.length > 0) {
                const glowScale = 1 + beat * 0.10 + state.explosion * 0.8;
                starGlow.forEach((glow, i) => {
                    const baseScale = 3.0 + i * 1.5;
                    const currentScale = baseScale * glowScale;
                    glow.scale.set(currentScale, currentScale);
                    glow.material.opacity = (0.40 - i * 0.04) + beat * 0.06 + state.explosion * 0.2;
                });
            }
            
            // 爆炸光圈动画
            if(explosionRings && explosionRings.length > 0) {
                explosionRings.forEach((ring, i) => {
                    if(state.explosion > 0.1) {
                        // 光圈持续扩散
                        ring.userData.scale += 0.5 * state.explosion;
                        ring.userData.opacity = Math.min(0.7, state.explosion * 1.2);
                        
                        // 重置过大的光圈
                        if(ring.userData.scale > 20) {
                            ring.userData.scale = ring.userData.baseScale;
                        }
                    } else {
                        // 慢慢消失
                        ring.userData.opacity *= 0.9;
                        if(ring.userData.opacity < 0.01) {
                            ring.userData.opacity = 0.1;
                            ring.userData.scale = ring.userData.baseScale;
                        }
                    }
                    
                    ring.scale.set(ring.userData.scale, ring.userData.scale);
                    ring.material.opacity = ring.userData.opacity;
                });
            }
            if(window.snowSystem) {
                const pos = window.snowSystem.geometry.attributes.position.array;
                
                // 更新雪花并添加拖尾
                if(window.snowTrailSystem) {
                    const trailPos = window.snowTrailSystem.geometry.attributes.position.array;
                    const trailAlpha = window.snowTrailSystem.geometry.attributes.alpha.array;
                    
                    for(let i=0; i<pos.length; i+=3) {
                        // 添加拖尾粒子
                        if(Math.random() < 0.15 && window.trailParticles.length < 600) {
                            const snowX = pos[i];
                            const snowY = pos[i+1];
                            const snowZ = pos[i+2];
                            
                            window.trailParticles.push({
                                x: snowX + (Math.random() - 0.5) * 0.3,
                                y: snowY + 0.2 + Math.random() * 0.2,
                                z: snowZ + (Math.random() - 0.5) * 0.3,
                                life: 1.0,
                                index: window.trailIndex
                            });
                            
                            trailPos[window.trailIndex] = window.trailParticles[window.trailParticles.length - 1].x;
                            trailPos[window.trailIndex + 1] = window.trailParticles[window.trailParticles.length - 1].y;
                            trailPos[window.trailIndex + 2] = window.trailParticles[window.trailParticles.length - 1].z;
                            trailAlpha[window.trailIndex / 3] = 0.6;
                            window.trailIndex = (window.trailIndex + 3) % trailPos.length;
                        }
                        
                        // 更新雪花位置
                        pos[i+1] -= 0.25;
                        if(pos[i+1] < -20) pos[i+1] = 100;
                    }
                    
                    // 更新拖尾粒子
                    for(let i = window.trailParticles.length - 1; i >= 0; i--) {
                        const trail = window.trailParticles[i];
                        trail.life -= 0.008;
                        trail.y -= 0.06;
                        
                        const idx = trail.index;
                        trailPos[idx] = trail.x;
                        trailPos[idx + 1] = trail.y;
                        trailPos[idx + 2] = trail.z;
                        trailAlpha[idx / 3] = trail.life * 0.6;
                        
                        if(trail.life <= 0) {
                            trailAlpha[idx / 3] = 0;
                            window.trailParticles.splice(i, 1);
                        }
                    }
                    
                    window.snowTrailSystem.geometry.attributes.position.needsUpdate = true;
                    window.snowTrailSystem.geometry.attributes.alpha.needsUpdate = true;
                } else {
                    for(let i=1; i<pos.length; i+=3) { pos[i] -= 0.25; if(pos[i]<-20) pos[i]=100; }
                }
                
                window.snowSystem.geometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }

        function startHandTracking() {
            const video = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            
            hands.onResults(results => {
                let leftFound = false;

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    for (let i = 0; i < results.multiHandedness.length; i++) {
                        const label = results.multiHandedness[i].label; // "Left" or "Right"
                        const lm = results.multiHandLandmarks[i];

                        if (label === 'Left') {
                            leftFound = true;
                            const d = Math.hypot(lm[4].x - lm[20].x, lm[4].y - lm[20].y);
                            state.targetExplosion = Math.min(Math.max((d - 0.15) * 4, 0), 1);
                        }
                    }
                }

                if (!leftFound) state.targetExplosion = 0;
            });

            const cameraUtils = new Camera(video, { onFrame: async () => { await hands.send({image: video}); }, width: 320, height: 240 });
            cameraUtils.start();
        }

        function createStar() {
            // 主星星 - 树顶大星星（发光效果）
            const s=new THREE.Shape(); const p=5; for(let i=0;i<p*2;i++){ const r=(i%2===0)?4:2; const a=i/p*Math.PI; s.lineTo(Math.cos(a)*r,Math.sin(a)*r); }
            const g=new THREE.ExtrudeGeometry(s,{depth:1,bevelEnabled:true,bevelThickness:0.5,bevelSize:0.2});
            starMesh=new THREE.Mesh(g,new THREE.MeshBasicMaterial({
                color: 0xffdd00,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide
            }));
            starMesh.position.y=state.treeHeight;
            treeGroup.add(starMesh);
            
            // 添加星星优雅光晕 - 使用Canvas纹理
            const glowCanvas = document.createElement('canvas');
            glowCanvas.width = 512;
            glowCanvas.height = 512;
            const glowCtx = glowCanvas.getContext('2d');
            
            // 创建优雅渐变纹理 - 更平滑的渐变
            const glowGradient = glowCtx.createRadialGradient(256, 256, 0, 256, 256, 256);
            glowGradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');
            glowGradient.addColorStop(0.08, 'rgba(255, 255, 240, 0.85)');
            glowGradient.addColorStop(0.16, 'rgba(255, 250, 220, 0.72)');
            glowGradient.addColorStop(0.24, 'rgba(255, 245, 200, 0.60)');
            glowGradient.addColorStop(0.32, 'rgba(255, 240, 180, 0.50)');
            glowGradient.addColorStop(0.40, 'rgba(255, 235, 160, 0.42)');
            glowGradient.addColorStop(0.48, 'rgba(255, 230, 140, 0.35)');
            glowGradient.addColorStop(0.56, 'rgba(255, 225, 120, 0.28)');
            glowGradient.addColorStop(0.64, 'rgba(255, 220, 100, 0.22)');
            glowGradient.addColorStop(0.72, 'rgba(255, 215, 80, 0.17)');
            glowGradient.addColorStop(0.80, 'rgba(255, 210, 60, 0.13)');
            glowGradient.addColorStop(0.88, 'rgba(255, 205, 40, 0.09)');
            glowGradient.addColorStop(0.94, 'rgba(255, 200, 20, 0.06)');
            glowGradient.addColorStop(1, 'rgba(255, 195, 0, 0)');
            
            glowCtx.fillStyle = glowGradient;
            glowCtx.fillRect(0, 0, 512, 512);
            
            const glowTexture = new THREE.CanvasTexture(glowCanvas);
            
            // 7层发散光晕
            const glowLayers = [
                { scale: 3.0, opacity: 0.40 },
                { scale: 4.5, opacity: 0.32 },
                { scale: 6.0, opacity: 0.26 },
                { scale: 7.5, opacity: 0.21 },
                { scale: 9.0, opacity: 0.17 },
                { scale: 10.5, opacity: 0.14 },
                { scale: 12.0, opacity: 0.12 }
            ];
            
            glowLayers.forEach(layer => {
                const glowMat = new THREE.SpriteMaterial({
                    map: glowTexture,
                    transparent: true,
                    opacity: layer.opacity,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                const glow = new THREE.Sprite(glowMat);
                glow.scale.set(layer.scale, layer.scale);
                glow.position.y = state.treeHeight;
                treeGroup.add(glow);
            });
            
            // 添加点光源
            const starLight = new THREE.PointLight(0xffdd00, 1.5, 60);
            starLight.position.y = state.treeHeight + 3;
            treeGroup.add(starLight);
            
            // 创建爆炸光圈系统 - 使用共享纹理
            const ringCanvas = document.createElement('canvas');
            ringCanvas.width = 256;
            ringCanvas.height = 256;
            const ringCtx = ringCanvas.getContext('2d');
            
            // 创建环形渐变
            const centerX = 128;
            const centerY = 128;
            const innerRadius = 80;
            const outerRadius = 120;
            
            // 绘制环形
            const ringGradient = ringCtx.createRadialGradient(centerX, centerY, innerRadius, centerX, centerY, outerRadius);
            ringGradient.addColorStop(0, 'rgba(255, 221, 0, 0)');
            ringGradient.addColorStop(0.5, 'rgba(255, 221, 0, 0.6)');
            ringGradient.addColorStop(1, 'rgba(255, 221, 0, 0)');
            
            ringCtx.fillStyle = ringGradient;
            ringCtx.fillRect(0, 0, 256, 256);
            
            const ringTexture = new THREE.CanvasTexture(ringCanvas);
            
            // 创建4个光圈，共享同一个纹理
            const ringCount = 4;
            for(let i = 0; i < ringCount; i++) {
                const ringMat = new THREE.SpriteMaterial({
                    map: ringTexture,
                    transparent: true,
                    opacity: 0,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const ring = new THREE.Sprite(ringMat);
                ring.position.y = state.treeHeight;
                ring.userData = {
                    baseScale: 2 + i * 0.8,
                    scale: 2 + i * 0.8,
                    opacity: 0.1
                };
                ring.scale.set(ring.userData.scale, ring.userData.scale);
                ring.material.opacity = ring.userData.opacity;
                explosionRings.push(ring);
                treeGroup.add(ring);
            }
            
            // 添加周围小星星装饰
            window.smallStars = [];
            for(let i=0; i<50; i++) {
                const starSize = 0.5 + Math.random() * 1.5;
                const starGeo = new THREE.SphereGeometry(starSize, 8, 8);
                const starMat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.05, 0.8, 0.5 + Math.random() * 0.5),
                    transparent: true,
                    opacity: 0.8
                });
                const star = new THREE.Mesh(starGeo, starMat);
                
                // 随机分布在树周围
                const angle = Math.random() * Math.PI * 2;
                const radius = 30 + Math.random() * 60;
                const height = Math.random() * state.treeHeight * 0.9;
                
                star.position.set(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                );
                
                window.smallStars.push(star);
                treeGroup.add(star);
            }
        }
        function createSnow() {
            const g=new THREE.BufferGeometry(); const pos=[]; for(let i=0;i<1000;i++) pos.push((Math.random()-0.5)*200,Math.random()*150,(Math.random()-0.5)*200);
            g.setAttribute('position',new THREE.Float32BufferAttribute(pos,3));
            
            // 创建圆形纹理
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.arc(16, 16, 14, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            const texture = new THREE.CanvasTexture(canvas);
            
            window.snowSystem=new THREE.Points(g,new THREE.PointsMaterial({
                map: texture,
                color:0xffffff,
                size:0.6,
                transparent:true,
                opacity:0.6,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            }));
            scene.add(window.snowSystem);
            
            // 创建拖尾粒子系统 - 更小、更淡、数量适中
            const trailCount = 800;
            const trailGeo = new THREE.BufferGeometry();
            const trailPos = new Float32Array(trailCount * 3);
            const trailAlpha = new Float32Array(trailCount);
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
            trailGeo.setAttribute('alpha', new THREE.BufferAttribute(trailAlpha, 1));
            
            window.snowTrailSystem = new THREE.Points(trailGeo, new THREE.PointsMaterial({
                map: texture,
                color: 0xffffff,
                size: 0.15,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            }));
            scene.add(window.snowTrailSystem);
            
            window.trailParticles = [];
            window.trailIndex = 0;
        }
        
        function createRibbonCurves() {
            const curveCount = 8;
            const ribbonColors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xff0099, 0xff6600];
            
            for(let c = 0; c < curveCount; c++) {
                const color = ribbonColors[c];
                const points = [];
                const radius = 35 + Math.random() * 30;
                const height = 15 + Math.random() * 60;
                const loops = 2 + Math.floor(Math.random() * 3);
                
                // 创建螺旋曲线点
                for(let i = 0; i <= loops * 100; i++) {
                    const angle = (i / 100) * Math.PI * 2 * loops + (c * Math.PI / 4);
                    const r = radius * (1 - i / (loops * 100));
                    const y = (i / (loops * 100)) * height;
                    points.push(new THREE.Vector3(
                        Math.cos(angle) * r,
                        y,
                        Math.sin(angle) * r
                    ));
                }
                
                // 创建曲线
                const curve = new THREE.CatmullRomCurve3(points);
                const tubeGeo = new THREE.TubeGeometry(curve, 100, 0.8, 8, false);
                const tubeMat = new THREE.MeshBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.5,
                    blending: THREE.AdditiveBlending
                });
                const tube = new THREE.Mesh(tubeGeo, tubeMat);
                ribbonCurves.push(tube);
                treeGroup.add(tube);
            }
        }
    </script>
</body>
</html>